// src/lib/services/menu-item-service.ts

import { buildHeaders } from "@/lib/util/service-helpers";

// Menu Item Pricing structure
export interface MenuItemPricing {
  basePrice: number;
  priceIncludesTax: boolean;
  currency: string;
}

// Menu Item Media
export interface MenuItemMedia {
  url: string;
  alt?: string;
  type: string;
}

// Menu Item matching Postman API
export interface TenantMenuItem {
  _id?: string;
  id?: string;
  name: string;
  slug?: string;
  code?: string;
  description?: string;
  categoryId: string; // Single category ID (not array)
  recipeId?: string; // Link to recipe
  pricing: MenuItemPricing;
  isActive: boolean;
  displayOrder?: number;
  tags?: string[];
  media?: MenuItemMedia[];
  branchIds?: string[];
  metadata?: Record<string, any>;
  createdAt?: string;
  updatedAt?: string;
}

export interface ApiListResponse<T> {
  success: boolean;
  message?: string;
  data?: T;
}

const REMOTE_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || process.env.NEXT_PUBLIC_API_BASE || "https://api.tritechtechnologyllc.com";
const USE_PROXY = (process.env.NEXT_PUBLIC_USE_API_PROXY || "true").toLowerCase() === "true";
const ITEMS_BASE = "/t/menu/items";

function buildUrl(path: string) {
  return USE_PROXY ? `/api${path}` : `${REMOTE_BASE}${path}`;
}

export const MenuItemService = {
  async listItems(params?: {
    q?: string;
    page?: number;
    limit?: number;
    categoryId?: string;
    status?: string;
    includeRecipeVariants?: boolean;
    includeCategoryAddOns?: boolean;
  }): Promise<ApiListResponse<TenantMenuItem[]>> {
    const q = params?.q ?? "";
    const page = params?.page ?? 1;
    const limit = params?.limit ?? 50;
    const categoryId = params?.categoryId ?? "";
    const status = params?.status ?? "";
    const includeRecipeVariants = params?.includeRecipeVariants ?? false;
    const includeCategoryAddOns = params?.includeCategoryAddOns ?? false;

    let url = buildUrl(`${ITEMS_BASE}?q=${encodeURIComponent(q)}&page=${page}&limit=${limit}`);
    if (categoryId) url += `&categoryId=${encodeURIComponent(categoryId)}`;
    if (status) url += `&status=${encodeURIComponent(status)}`;
    if (includeRecipeVariants) url += `&includeRecipeVariants=1`;
    if (includeCategoryAddOns) url += `&includeCategoryAddOns=1`;

    const res = await fetch(url, { headers: buildHeaders() });
    const data = await res.json().catch(() => ({}));

    if (!res.ok) {
      return { success: false, message: data?.message || `List items failed (${res.status})` };
    }

    // Backend returns: { status, message, items: [...], count, page, limit }
    const items: TenantMenuItem[] = data?.items ?? data?.result ?? [];
    return { success: true, data: items };
  },

  async getItem(id: string, params?: {
    includeRecipeVariants?: boolean;
    includeCategoryAddOns?: boolean;
  }): Promise<ApiListResponse<TenantMenuItem>> {
    const includeRecipeVariants = params?.includeRecipeVariants ?? false;
    const includeCategoryAddOns = params?.includeCategoryAddOns ?? false;

    let url = buildUrl(`${ITEMS_BASE}/${id}`);
    const queryParams = [];
    if (includeRecipeVariants) queryParams.push(`includeRecipeVariants=1`);
    if (includeCategoryAddOns) queryParams.push(`includeCategoryAddOns=1`);
    if (queryParams.length > 0) url += `?${queryParams.join("&")}`;

    const res = await fetch(url, { headers: buildHeaders() });
    const data = await res.json().catch(() => ({}));

    if (!res.ok) {
      return { success: false, message: data?.message || `Get item failed (${res.status})` };
    }

    // Handle different API response structures
    const item: TenantMenuItem = data?.result ?? data?.data ?? data;
    return { success: true, data: item };
  },

  async createItem(payload: Partial<TenantMenuItem>): Promise<ApiListResponse<TenantMenuItem>> {
    const url = buildUrl(`${ITEMS_BASE}`);

    // Map to Postman API format
    const apiPayload: any = {
      name: payload.name,
      description: payload.description ?? "",
      categoryId: payload.categoryId, // Single category ID
      recipeId: payload.recipeId,
      pricing: payload.pricing ?? {
        basePrice: 0,
        priceIncludesTax: false,
        currency: "SAR"
      },
      isActive: payload.isActive ?? true,
      displayOrder: payload.displayOrder ?? 0,
      tags: payload.tags ?? [],
      media: payload.media ?? [],
      branchIds: payload.branchIds ?? [],
      metadata: payload.metadata ?? {}
    };

    // Slug and code are auto-generated by backend
    if (payload.code) apiPayload.code = payload.code;

    const res = await fetch(url, {
      method: "POST",
      headers: buildHeaders(),
      body: JSON.stringify(apiPayload),
    });
    const data = await res.json().catch(() => ({}));

    console.log("ðŸ”§ MenuItemService.createItem - API response:", data);

    if (!res.ok) {
      return { success: false, message: data?.message || `Create item failed (${res.status})` };
    }

    // Handle different API response structures
    const item: TenantMenuItem = data?.result ?? data?.data ?? data;
    console.log("ðŸ”§ MenuItemService.createItem - Extracted item:", item);

    return { success: true, data: item };
  },

  async updateItem(id: string, payload: Partial<TenantMenuItem>): Promise<ApiListResponse<TenantMenuItem>> {
    const url = buildUrl(`${ITEMS_BASE}/${id}`);

    // Map to Postman API format - only include fields being updated
    const apiPayload: any = {};
    if (payload.name !== undefined) apiPayload.name = payload.name;
    if (payload.description !== undefined) apiPayload.description = payload.description;
    if (payload.categoryId !== undefined) apiPayload.categoryId = payload.categoryId;
    if (payload.recipeId !== undefined) apiPayload.recipeId = payload.recipeId;
    if (payload.pricing !== undefined) apiPayload.pricing = payload.pricing;
    if (payload.isActive !== undefined) apiPayload.isActive = payload.isActive;
    if (payload.displayOrder !== undefined) apiPayload.displayOrder = payload.displayOrder;
    if (payload.tags !== undefined) apiPayload.tags = payload.tags;
    if (payload.media !== undefined) apiPayload.media = payload.media;
    if (payload.branchIds !== undefined) apiPayload.branchIds = payload.branchIds;
    if (payload.metadata !== undefined) apiPayload.metadata = payload.metadata;
    if (payload.code !== undefined) apiPayload.code = payload.code;

    const res = await fetch(url, {
      method: "PUT",
      headers: buildHeaders(),
      body: JSON.stringify(apiPayload),
    });
    const data = await res.json().catch(() => ({}));

    if (!res.ok) {
      return { success: false, message: data?.message || `Update item failed (${res.status})` };
    }

    // Handle different API response structures
    const item: TenantMenuItem = data?.result ?? data?.data ?? data;
    return { success: true, data: item };
  },

  async deleteItem(id: string): Promise<ApiListResponse<null>> {
    const url = buildUrl(`${ITEMS_BASE}/${id}`);
    const res = await fetch(url, { method: "DELETE", headers: buildHeaders() });

    if (!res.ok) {
      const data = await res.json().catch(() => ({}));
      return { success: false, message: data?.message || `Delete item failed (${res.status})` };
    }

    return { success: true, data: null };
  },
};
